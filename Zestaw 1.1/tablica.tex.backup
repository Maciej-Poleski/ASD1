\documentclass[a4paper,12pt]{article}
%\documentclass[a4paper,12pt]{scrartcl}

\usepackage[utf8x]{inputenc}
\usepackage{polski}

\title{Zadania domowe. Zestaw 1.1}
\author{Maciej Poleski}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{listings}

\date{\today}

\pdfinfo{%
  /Title    (Zadania domowe. Zestaw 1.1)
  /Author   (Maciej Poleski)
  /Creator  (Maciej Poleski)
  /Producer (Maciej Poleski)
  /Subject  (MP)
  /Keywords (MP)
}

\begin{document}
\maketitle

\newpage

\section{}
W trakcie standardowego algorytmu \verb|LIS| dla każdej pozycji $i$ znamy długość najdłuższego podciągu rosnącego kończącego się w pozycji $i$. Skoro tak, to można puścić algorytm od dwóch stron (od początku ciągu i od końca) i dodać do siebie odpowiednie wyniki (-1 z powodu podwójnego policzenia pozycji $i$).
\begin{alltt}
LIS(A):
    T[0] <- 0
    for i <- 1 to n]:
        T[i] <- \(\infty\)

    for k=0 to n):
        s <- lower-bound A[k] in T[]
        T[s] <- A[k]
        S[k] <- s
    return S[]

LEFT[] <- LIS(T[])
for i <- 0 to n):
    TR[i] <- -T[n-1-i]
RIGHT[] <- LIS(TR[])

for i <- 0 to n):
    ANS[i] <- LEFT[i] + RIGHT[n-1-i] - 1

\end{alltt}
Funkcja \verb|lower-bound| (omówiona na MP) zwraca indeks pierwszego elementu w zadanym ciągu nie mniejszego niż zadana wartość. Odpowiedź jest zapisana w tablicy \verb|ANS[0..n-1]|. Złożoność jest złożonością standardowego algorytmu \verb|LIS|.

\section{}
Analogicznie do LCS. Tablice (słowa) \verb|A| i \verb|B| indeksujemy od 1.
\begin{alltt}
for each i: T[0][i] <- i
for each i: T[i][0] <- i

for i <- 1 to n]:
    for j <- 1 to n]:
        T[i][j] <- min\{
            A[i]=B[j] ? T[i-1][j-1]+1 : \(\infty\),
            T[i-1][j]+1,
            T[i][j-1]+1\}

i <- n
j <- n

S <- make-stack()

while i != 0 and j != 0:
    if A[i]=B[j] and T[i][j]=T[i-1][j-1]+1:
        push A[i] to S
        i <- i-1
        j <- j-1
    else if T[i][j]=T[i-1][j]+1:
        push A[i] to S
        i <- i-1
    else:
        push B[j] to S
        j <- j-1

while S is not empty:
    print top of S
    pop from S

\end{alltt}
Działa dlatego że budując optymalnie słowo dla \verb|A[1..i]| i \verb|B[1..j]| możemy wykorzystać optymalne słowo dla \verb|A[1..i-1]| i \verb|B[1..j-1]| (jeżeli \verb|A[i]=B[j]|) oraz optymalne słowo dla \verb|A[1..i-1]| i \verb|B[1..j]| oraz optymalne słowo dla \verb|A[1..i]| i \verb|B[1..j-1]|. W każdym z tych przypadków dodając jedną brakującą literę na koniec słowa. Potem odtwarzamy rozwiązanie analizując od końca który wybór był optymalny. Przy użyciu stosu odwracam odwrócone słowo.

Pierwsze dwie pętle są liniowe, potem pojawią się pętla zagnieżdżona podwójnie (kwadratowa) i dwie pętle wykonujące się tyle razy ile wynosi długość wynikowego słowa ($\leq2n$ czyli liniowe). Wobec tego złożoność całości jest kwadratowa (względem długości słów).

\section{}
Tablice (słowa) \verb|A| i \verb|B| indeksujemy od 1.
\begin{alltt}
for each i: T[0][i] <- 0
for each i: T[i][0] <- 0

max <- 0
maxi <- 0
maxj <- 0

for i <- 1 to n]:
    for j <- 1 to n]:
        if A[i]!=B[j]:
            T[i][j] <- 0
        else:
            T[i][j]=T[i-1][j-1]+1
            if T[i][j]>max:
                maxi <- i
                maxj <- j

for i <- maxi-max to maxi:
    print A[i]
\end{alltt}


\end{document}
