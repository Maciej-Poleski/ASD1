\documentclass[a4paper,12pt]{article}
%\documentclass[a4paper,12pt]{scrartcl}

\usepackage[utf8x]{inputenc}
\usepackage{polski}

\title{Zadania domowe. Zestaw 2.1}
\author{Maciej Poleski}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{listings}

\date{\today}

\pdfinfo{%
  /Title    (Zadania domowe. Zestaw 2.1)
  /Author   (Maciej Poleski)
  /Creator  (Maciej Poleski)
  /Producer (Maciej Poleski)
  /Subject  (ASD1)
  /Keywords (ASD1)
}

\begin{document}
\maketitle

\newpage

\section{}
Wystarczy posortować. Załóżmy że \verb|A[1..n]| i \verb|B[1..n]| są posortowane nie rosnąco. Istnieje optymalne rozwiązanie takie że A[i] jest w tym samym filmie co B[i]. Weźmy 4 indeksy $0<a<b\leq{n}$ i $0<c<d\leq{n}$. Jeżeli $a$ nie było by w tym samym filmie co $c$, to istnieje $b$ i $d$ takie że $a$ jest z $d$ i $b$ jest z $c$ (ponieważ wszystkie mniejsze indeksy są już zajęte). Skoro tablice są posortowane, to \verb|A[a]|$=$\verb|A[b]|$+x$ gdzie $x\geq{0}$ oraz \verb|B[c]|$=$\verb|B[d]|$+y$ gdzie $y\geq{0}$. Ale ponieważ $$(A[b]+x)(B[d]+y)+ A[b]B[d] = 2A[b]B[d]+A[b]y+B[d]x+xy\geq$$
$$\geq 2A[b]B[d]+A[b]y+B[d]x = A[b](B[d]+y)+B[d](A[b]+x)$$
więc nasze sparowanie jest nie gorsze od dowolnego innego.

Złożoność obliczeniowa to koszt sortowania, czyli $O(n\log(n))$.
Pseudokodu nie będzie. Całe zadanie polega na przesortowaniu tablicy wskaźników do kolejnych elementów tablicy wejściowej. Wystarczająco efektywne algorytmy zostały omówione na MP.
\section{}
Istnieje rozwiązanie optymalne, w którym każdy punkt jest możliwie blisko 0. Weźmy optymalne rozwiązanie o minimalnej odległości. Zaczynając od lewej strony (od 0) przesuwamy każdy punkt maksymalnie na lewo (tak aby nie zmniejszyć minimalnej odległości z jego lewej strony). W efekcie na pewno nie zmniejszymy minimalnej odległości z jego prawej strony. Wynika z tego, że skrajnie lewy punkt zawsze należy do jakiegoś rozwiązania optymalnego. Możemy poszukać minimalnej odległości binarnie.
\begin{alltt}
 A[0..n-1] <- tablica ze współrzędnymi punktów na osi liczbowej
 if k = 0:
    return \(\varnothing\)
 else if k = 1:
    return \{A[0]\}
 sort(A)
 l <- 0
 r <- max(A) - min(A) + 1
 while l < r:
    s <- (l+r)/2
    v <- 0
    a <- \(-\infty\)
    for i <- 0 to n):
        if a + s <= A[i]:
            v <- v + 1
            a <- A[i]
    if v < k:
        r <- s
    else
        l <- s+1
 s <- pusty zbiór
 a <- \(-\infty\)
 for i <- 0 to n):
    if a + r-1 <= A[i]:
        s <- s \(\cup\) \{A[i]\}
        a <- A[i]
        if \(|s|\)=k:
            return s
\end{alltt}
Na uwagę zasługuje funkcja \verb|sort|. Aby uzyskać złożoność wymaganą w treści zadania można użyć algorytmu quicksort jako pivot wybierając punkt na środku przedziału (niekoniecznie istniejący!). Czyli algorytm przyjmowałby jako parametry przedział w tablicy (do posortowania) i odpowiadający mu przedział na osi liczbowej. Po wykonaniu $\log_2(\max_i{|x_i|})$ razy operacji wybierania pivota uzyskamy przedział jednostkowy na osi liczbowej kończąc tym samym sortowanie danego przedziału. Jednak dla rozsądnych danych ($n>\max_i{|x_i|}$) efektywniej będzie zastosować standardowy algorytm działający w $n\log(n)$. Reszta algorytmu to wyszukiwanie binarne największej możliwej minimalnej odległości między dowolnie wybranymi zbiorem co najmniej $k$ punktów. Na koniec konstruowany jest sam zbiór w oparciu o informacje o minimalnej odległości.
\section{}


\end{document}
